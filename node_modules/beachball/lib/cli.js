"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bump_1 = require("./bump");
const paths_1 = require("./paths");
const git_1 = require("./git");
const validation_1 = require("./validation");
const changefile_1 = require("./changefile");
const publish_1 = require("./publish");
const yargs_parser_1 = __importDefault(require("yargs-parser"));
let argv = process.argv.splice(2);
let args = yargs_parser_1.default(argv, {
    alias: {
        branch: ['b'],
        tag: ['t'],
        registry: ['r'],
        message: ['m'],
        token: ['n'],
        help: ['h', '?'],
        yes: ['y'],
        package: ['p']
    }
});
if (args.help) {
    showHelp();
    process.exit(0);
}
if (args.branch && !validation_1.isValidTargetBranch(args.branch)) {
    console.error(`Target branch needs to be a valid remote branch (e.g. origin/master): ${args.branch}`);
    process.exit(1);
}
const defaultCommand = 'change';
const cwd = paths_1.findGitRoot(process.cwd()) || process.cwd();
const options = {
    branch: args.branch || git_1.getDefaultRemoteMaster(cwd),
    command: args._.length === 0 ? defaultCommand : args._[0],
    message: args.message || 'applying package updates',
    path: cwd,
    publish: args.publish === false ? false : true,
    push: args.push === false ? false : true,
    registry: args.registry || 'https://registry.npmjs.org/',
    tag: args.tag || 'latest',
    token: args.token || '',
    yes: args.yes === true || false,
    access: args.access || 'restricted',
    package: args.package || ''
};
(() => __awaiter(this, void 0, void 0, function* () {
    // Validation Steps
    if (!validation_1.isGitAvailable(options.path)) {
        console.error('ERROR: Please make sure git is installed and initialize the repository with "git init".');
        process.exit(1);
    }
    const uncommitted = git_1.getUncommittedChanges(options.path);
    if (uncommitted && uncommitted.length > 0) {
        console.error('ERROR: There are uncommitted changes in your repository. Please commit these files first:');
        console.error('- ' + uncommitted.join('\n- '));
        process.exit(1);
    }
    const isChangeNeeded = validation_1.isChangeFileNeeded(options.branch, options.path);
    if (isChangeNeeded && options.command !== 'change') {
        console.error('ERROR: Change files are needed! Run "beachball" to generate change files.');
        process.exit(1);
    }
    if (options.package && !validation_1.isValidPackageName(options.package, options.path)) {
        console.error('ERROR: Specified package name is not valid');
        process.exit(1);
    }
    switch (options.command) {
        case 'check':
            console.log('No change files are needed');
            break;
        case 'publish':
            publish_1.publish(options);
            break;
        case 'bump':
            bump_1.bump(options.path);
            break;
        default:
            if (!isChangeNeeded && !options.package) {
                console.log('No change files are needed');
                return;
            }
            const changes = yield changefile_1.promptForChange(options.branch, options.package, options.path);
            if (changes) {
                changefile_1.writeChangeFiles(changes, options.path);
            }
            break;
    }
}))();
function showHelp() {
    const packageJson = require('../package.json');
    console.log(`beachball v${packageJson.version} - the sunniest version bumping tool

Prerequisites:

  git and a remote named "origin"

Usage:

  beachball [command] [options]

Commands:

  change (default)    - a tool to help create change files in the change/ folder
  check               - checks whether a change file is needed for this branch
  changelog           - based on change files, create changelogs and then unlinks the change files
  bump                - bumps versions as well as generating changelogs
  publish             - bumps, publishes to npm registry (optionally does dist-tags), and pushes changelogs back into master

Options:

  --registry, -r      - registry, defaults to https://registry.npmjs.org
  --tag, -t           - dist-tag for npm publishes
  --branch, -b        - target branch from origin (default: master)
  --message, -m       - custom message for the checkin (default: applying package updates)
  --no-push           - skip pushing changes back to git remote origin
  --no-publish        - skip publishing to the npm registry
  --help, -?, -h      - this very help message
  --yes, -y           - skips the prompts for publish
  --package, -p       - manually specify a package to create a change file; creates a change file regardless of diffs

Examples:

  $ beachball
  $ beachball check
  $ beachball publish -r http://localhost:4873 -t beta -b beta

`);
}
