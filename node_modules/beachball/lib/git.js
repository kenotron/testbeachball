"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const paths_1 = require("./paths");
const git_url_parse_1 = __importDefault(require("git-url-parse"));
function git(args, options) {
    const results = child_process_1.spawnSync('git', args, options);
    if (results.status === 0) {
        return {
            stderr: results.stderr.toString().trim(),
            stdout: results.stdout.toString().trim(),
            success: true
        };
    }
    else {
        return {
            stderr: results.stderr.toString().trim(),
            stdout: results.stdout.toString().trim(),
            success: false
        };
    }
}
exports.git = git;
function getUncommittedChanges(cwd) {
    try {
        const results = git(['status', '--porcelain'], { cwd });
        if (!results.success) {
            return [];
        }
        const changes = results.stdout;
        if (changes.length == 0) {
            return [];
        }
        const lines = changes.split(/\n/) || [];
        return lines.map(line => line.trim().split(/\s+/)[1]);
    }
    catch (e) {
        console.error('Cannot gather information about changes: ', e.message);
    }
}
exports.getUncommittedChanges = getUncommittedChanges;
function getChanges(branch, cwd) {
    try {
        const results = git(['--no-pager', 'diff', '--name-only', branch + '...'], { cwd });
        if (!results.success) {
            return [];
        }
        let changes = results.stdout;
        let lines = changes.split(/\n/) || [];
        return lines.filter(line => line.trim() !== '').map(line => line.trim());
    }
    catch (e) {
        console.error('Cannot gather information about changes: ', e.message);
    }
}
exports.getChanges = getChanges;
function getRecentCommitMessages(branch, cwd) {
    try {
        const results = git(['log', '--decorate', '--pretty=format:%s', branch, 'HEAD'], { cwd });
        if (!results.success) {
            return [];
        }
        let changes = results.stdout;
        let lines = changes.split(/\n/) || [];
        return lines.map(line => line.trim());
    }
    catch (e) {
        console.error('Cannot gather information about recent commits: ', e.message);
    }
}
exports.getRecentCommitMessages = getRecentCommitMessages;
function getUserEmail(cwd) {
    try {
        const results = git(['config', 'user.email'], { cwd });
        if (!results.success) {
            return null;
        }
        return results.stdout;
    }
    catch (e) {
        console.error('Cannot gather information about user.email: ', e.message);
    }
}
exports.getUserEmail = getUserEmail;
function getBranchName(cwd) {
    try {
        const results = git(['rev-parse', '--abbrev-ref', 'HEAD'], { cwd });
        if (results.success) {
            return results.stdout;
        }
    }
    catch (e) {
        console.error('Cannot get branch name: ', e.message);
    }
    return null;
}
exports.getBranchName = getBranchName;
function getFullBranchRef(branch, cwd) {
    const showRefResults = git(['show-ref', '--heads', branch], { cwd });
    if (showRefResults.success) {
        return showRefResults.stdout.split(' ')[1];
    }
    return null;
}
exports.getFullBranchRef = getFullBranchRef;
function getShortBranchName(fullBranchRef, cwd) {
    const showRefResults = git(['name-rev', '--name-only', fullBranchRef], { cwd });
    if (showRefResults.success) {
        return showRefResults.stdout;
    }
    return null;
}
exports.getShortBranchName = getShortBranchName;
function getCurrentHash(cwd) {
    try {
        const results = git(['rev-parse', 'HEAD'], { cwd });
        if (results.success) {
            return results.stdout;
        }
    }
    catch (e) {
        console.error('Cannot get current git hash');
    }
    return null;
}
exports.getCurrentHash = getCurrentHash;
function stageAndCommit(patterns, message, cwd) {
    try {
        patterns.forEach(pattern => {
            git(['add', pattern], { cwd });
        });
        const commitResults = git(['commit', '-m', message], { cwd });
        if (!commitResults.success) {
            console.error('Cannot commit changes');
            console.log(commitResults.stdout);
            console.error(commitResults.stderr);
        }
    }
    catch (e) {
        console.error('Cannot stage and commit changes', e.message);
    }
}
exports.stageAndCommit = stageAndCommit;
function revertLocalChanges(cwd) {
    const stash = `beachball_${new Date().getTime()}`;
    git(['stash', 'push', '-u', '-m', stash], { cwd });
    const results = git(['stash', 'list']);
    if (results.success) {
        const lines = results.stdout.split(/\n/);
        const foundLine = lines.find(line => line.includes(stash));
        if (foundLine) {
            const matched = foundLine.match(/^[^:]+/);
            if (matched) {
                git(['stash', 'drop', matched[0]]);
                return true;
            }
        }
    }
    return false;
}
exports.revertLocalChanges = revertLocalChanges;
function getParentBranch(cwd) {
    const branchName = getBranchName(cwd);
    if (!branchName || branchName === 'HEAD') {
        return null;
    }
    const showBranchResult = git(['show-branch', '-a'], { cwd });
    if (showBranchResult.success) {
        const showBranchLines = showBranchResult.stdout.split(/\n/);
        const parentLine = showBranchLines.find(line => line.indexOf('*') > -1 && line.indexOf(branchName) < 0 && line.indexOf('publish_') < 0);
        if (!parentLine) {
            return null;
        }
        const matched = parentLine.match(/\[(.*)\]/);
        if (!matched) {
            return null;
        }
        return matched[1];
    }
    return null;
}
exports.getParentBranch = getParentBranch;
function getRemoteBranch(branch, cwd) {
    const results = git(['rev-parse', '--abbrev-ref', '--symbolic-full-name', `${branch}@\{u\}`], { cwd });
    if (results.success) {
        return results.stdout.trim();
    }
    return null;
}
exports.getRemoteBranch = getRemoteBranch;
function parseRemoteBranch(branch) {
    const firstSlashPos = branch.indexOf('/', 0);
    const remote = branch.substring(0, firstSlashPos);
    const remoteBranch = branch.substring(firstSlashPos + 1);
    return {
        remote,
        remoteBranch
    };
}
exports.parseRemoteBranch = parseRemoteBranch;
function normalizeRepoUrl(repositoryUrl) {
    try {
        const parsed = git_url_parse_1.default(repositoryUrl);
        return parsed
            .toString('https')
            .replace(/\.git$/, '')
            .toLowerCase();
    }
    catch (e) {
        return '';
    }
}
function getDefaultRemoteMaster(cwd) {
    let packageJson;
    try {
        packageJson = JSON.parse(fs_1.default.readFileSync(path_1.default.join(paths_1.findGitRoot(cwd), 'package.json')).toString());
    }
    catch (e) {
        console.log('failed to read package.json');
        throw new Error('invalid package.json detected');
    }
    const { repository } = packageJson;
    let repositoryUrl = '';
    if (typeof repository === 'string') {
        repositoryUrl = repository;
    }
    else if (repository && repository.url) {
        repositoryUrl = repository.url;
    }
    const normalizedUrl = normalizeRepoUrl(repositoryUrl);
    const remotesResult = git(['remote', '-v'], { cwd });
    if (remotesResult.success) {
        const allRemotes = {};
        remotesResult.stdout.split('\n').forEach(line => {
            const parts = line.split(/\s+/);
            allRemotes[normalizeRepoUrl(parts[1])] = parts[0];
        });
        if (Object.keys(allRemotes).length > 0) {
            const remote = allRemotes[normalizedUrl];
            if (remote) {
                console.log(`Found a matching remote URL from package.json named "${remote}/master"`);
                return `${remote}/master`;
            }
        }
    }
    console.log(`Defaults to "origin/master"`);
    return 'origin/master';
}
exports.getDefaultRemoteMaster = getDefaultRemoteMaster;
function listAllTrackedFiles(cwd) {
    const results = git(['ls-tree', '-r', '--name-only', '--full-tree', 'HEAD'], { cwd });
    if (results.success) {
        return results.stdout.split(/\n/);
    }
    return [];
}
exports.listAllTrackedFiles = listAllTrackedFiles;
