"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bump_1 = require("./bump");
const git_1 = require("./git");
const packageManager_1 = require("./packageManager");
const prompts_1 = __importDefault(require("prompts"));
const tag_1 = require("./tag");
function publish(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const { path: cwd, branch, registry, tag, token, message, access } = options;
        const currentBranch = git_1.getBranchName(cwd);
        console.log(`Publishing with the following configuration:

  registry: ${registry}
  
  current branch: ${currentBranch}
  target branch: ${branch}
  tag: ${tag}

  publishes to npm registry: ${options.publish ? 'yes' : 'no'}
  pushes to remote git repo: ${options.push && options.branch ? 'yes' : 'no'}

`);
        if (!options.yes) {
            const response = yield prompts_1.default({
                type: 'confirm',
                name: 'yes',
                message: 'Is everything correct (use the --yes or -y arg to skip this prompt)?'
            });
            if (!response.yes) {
                return;
            }
        }
        // checkout publish branch
        const publishBranch = 'publish_' + String(new Date().getTime());
        git_1.git(['checkout', '-b', publishBranch]);
        // Step 1. Bump + npm publish
        // bump the version
        console.log('Bumping version for npm publish');
        const bumpInfo = bump_1.bump(cwd);
        if (!validatePackageVersions(bumpInfo, registry)) {
            displayManualRecovery(bumpInfo);
            console.error('No packages have been published');
            process.exit(1);
        }
        // npm / yarn publish
        if (options.publish) {
            Object.keys(bumpInfo.packageChangeTypes).forEach(pkg => {
                const packageInfo = bumpInfo.packageInfos[pkg];
                console.log(`Publishing - ${packageInfo.name}@${packageInfo.version}`);
                const result = packageManager_1.packagePublish(packageInfo, registry, token, tag, access);
                if (result.success) {
                    console.log('Published!');
                }
                else {
                    displayManualRecovery(bumpInfo);
                    console.error(result.stderr);
                    process.exit(1);
                    return;
                }
            });
        }
        else {
            console.log('Skipping publish');
        }
        // Step 2.
        // - reset, fetch latest from origin/master (to ensure less chance of conflict), then bump again + commit
        if (!branch || !options.push) {
            console.log('Skipping git push and tagging');
        }
        else {
            const { remote, remoteBranch } = git_1.parseRemoteBranch(branch);
            console.log('Reverting and fetching from remote');
            // pull in latest from origin branch
            git_1.revertLocalChanges(cwd);
            git_1.git(['fetch', remote], { cwd });
            const mergeResult = git_1.git(['merge', '-X', 'theirs', `${branch}`], { cwd });
            if (!mergeResult.success) {
                console.error(`CRITICAL ERROR: pull from ${branch} has failed!`);
                console.error(mergeResult.stderr);
                displayManualRecovery(bumpInfo);
                process.exit(1);
            }
            // bump the version
            console.log('Bumping the versions for git push');
            bump_1.bump(cwd);
            // checkin
            const mergePublishBranchResult = mergePublishBranch(publishBranch, branch, message, cwd);
            if (!mergePublishBranchResult.success) {
                console.error('CRITICAL ERROR: merging to target has failed!');
                displayManualRecovery(bumpInfo);
                process.exit(1);
            }
            // Step 3. Tag & Push to remote
            tagPackages(bumpInfo, tag, cwd);
            console.log(`pushing to ${branch}, running the following command for git push:`);
            const pushArgs = ['push', '--follow-tags', '--no-verify', '--verbose', remote, `HEAD:${remoteBranch}`];
            console.log('git ' + pushArgs.join(' '));
            git_1.git(pushArgs);
        }
    });
}
exports.publish = publish;
function displayManualRecovery(bumpInfo) {
    console.error('Something went wrong with the publish! Manually update these package and versions:');
    Object.keys(bumpInfo.packageChangeTypes).forEach(pkg => {
        const packageInfo = bumpInfo.packageInfos[pkg];
        console.error(`- ${packageInfo.name}@${packageInfo.version}`);
    });
}
function mergePublishBranch(publishBranch, branch, message, cwd) {
    git_1.git(['add', '.'], { cwd });
    git_1.git(['commit', '-m', message], { cwd });
    git_1.git(['checkout', branch], { cwd });
    const mergePublishBranchResult = git_1.git(['merge', '-X', 'ours', publishBranch], { cwd });
    if (mergePublishBranchResult.success) {
        git_1.git(['branch', '-D', publishBranch]);
    }
    return mergePublishBranchResult;
}
function tagPackages(bumpInfo, tag, cwd) {
    Object.keys(bumpInfo.packageChangeTypes).forEach(pkg => {
        const packageInfo = bumpInfo.packageInfos[pkg];
        console.log(`Tagging - ${packageInfo.name}@${packageInfo.version}`);
        git_1.git(['tag', tag_1.generateTag(packageInfo.name, packageInfo.version)], { cwd });
    });
    // Adds a special dist-tag based tag in git
    if (tag !== 'latest') {
        git_1.git(['tag', '-f', tag], { cwd });
    }
}
function validatePackageVersions(bumpInfo, registry) {
    let hasErrors = false;
    Object.keys(bumpInfo.packageChangeTypes).forEach(pkg => {
        const packageInfo = bumpInfo.packageInfos[pkg];
        process.stdout.write(`Validating package version - ${packageInfo.name}@${packageInfo.version}`);
        const publishedVersions = packageManager_1.listPackageVersions(packageInfo.name, registry);
        if (publishedVersions.includes(packageInfo.version)) {
            console.error(`\nERROR: Attempting to bump to a version that already exists in the registry: ${packageInfo.name}@${packageInfo.version}`);
            hasErrors = true;
        }
        else {
            process.stdout.write(' OK!\n');
        }
    });
    return !hasErrors;
}
