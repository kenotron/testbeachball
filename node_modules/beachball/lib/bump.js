"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const paths_1 = require("./paths");
const changefile_1 = require("./changefile");
const monorepo_1 = require("./monorepo");
const changelog_1 = require("./changelog");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
function bump(cwd) {
    const gitRoot = paths_1.findGitRoot(cwd) || cwd;
    // Collate the changes per package
    const packageChangeTypes = changefile_1.getPackageChangeTypes(cwd);
    // Gather all package info from package.json
    const packageInfos = monorepo_1.getPackageInfos(cwd);
    // Apply package.json version updates
    Object.keys(packageChangeTypes).forEach(pkgName => {
        const info = packageInfos[pkgName];
        if (!info) {
            console.log(`Unknown package named "${pkgName}" detected from change files, skipping!`);
            return;
        }
        const changeType = packageChangeTypes[pkgName];
        const packageJsonPath = path_1.default.join(gitRoot, info.packageJsonPath);
        const packageJson = JSON.parse(fs_1.default.readFileSync(packageJsonPath).toString());
        if (changeType !== 'none') {
            packageJson.version = semver_1.default.inc(packageJson.version, changeType);
            info.version = packageJson.version;
        }
        fs_1.default.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n');
    });
    // Apply package dependency bumps
    Object.keys(packageInfos).forEach(pkgName => {
        const info = packageInfos[pkgName];
        const packageJsonPath = path_1.default.join(gitRoot, info.packageJsonPath);
        const packageJson = JSON.parse(fs_1.default.readFileSync(packageJsonPath).toString());
        ['dependencies', 'devDependencies'].forEach(depKind => {
            if (packageJson[depKind]) {
                Object.keys(packageJson[depKind]).forEach(dep => {
                    const packageInfo = packageInfos[dep];
                    if (packageInfo) {
                        const existingVersionRange = packageJson[depKind][dep];
                        packageJson[depKind][dep] = bumpMinSemverRange(packageInfo.version, existingVersionRange);
                    }
                });
            }
        });
        fs_1.default.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n');
    });
    // Generate changelog
    changelog_1.writeChangelog(packageInfos, cwd);
    return {
        packageChangeTypes,
        packageInfos
    };
}
exports.bump = bump;
function bumpMinSemverRange(minVersion, semverRange) {
    if (semverRange.startsWith('~') || semverRange.startsWith('^')) {
        // ~1.0.0
        // ^1.0.0
        return semverRange[0] + minVersion;
    }
    else if (semverRange.includes('>')) {
        // >=1.0.0 <2.0.0
        return `>=${minVersion} <${semver_1.default.inc(minVersion, 'major')}`;
    }
    else if (semverRange.includes(' - ')) {
        // 1.0.0 - 2.0.0
        return `${minVersion} - ${semver_1.default.inc(minVersion, 'major')}`;
    }
    return minVersion;
}
