"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const getChangedPackages_1 = require("./getChangedPackages");
const paths_1 = require("./paths");
const git_1 = require("./git");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const prompts_1 = __importDefault(require("prompts"));
const monorepo_1 = require("./monorepo");
const semver_1 = require("semver");
/**
 * Uses `prompts` package to prompt for change type and description, fills in git user.email, scope, and the commit hash
 * @param cwd
 */
function promptForChange(branch, specificPackage, cwd) {
    return __awaiter(this, void 0, void 0, function* () {
        const changedPackages = specificPackage ? [specificPackage] : getChangedPackages_1.getChangedPackages(branch, cwd);
        const recentMessages = git_1.getRecentCommitMessages(branch, cwd) || [];
        const packageChangeInfo = {};
        const packageInfos = monorepo_1.getPackageInfos(cwd);
        for (let pkg of changedPackages) {
            console.log('');
            console.log(`Please describe the changes for: ${pkg}`);
            const showPrereleaseOption = semver_1.prerelease(packageInfos[pkg].version);
            const changeTypePrompt = {
                type: 'select',
                name: 'type',
                message: 'Change type',
                choices: [
                    ...(showPrereleaseOption ? [{ value: 'prerelease', title: ' [1mPrerelease[22m - bump prerelease version' }] : []),
                    { value: 'patch', title: ' [1mPatch[22m      - bug fixes; no backwards incompatible changes.' },
                    { value: 'minor', title: ' [1mMinor[22m      - small feature; backwards compatible changes.' },
                    { value: 'none', title: ' [1mNone[22m       - this change does not affect the published package in any way.' },
                    { value: 'major', title: ' [1mMajor[22m      - major feature; breaking changes.' }
                ].filter(choice => !packageInfos[pkg].disallowedChangeTypes.includes(choice.value))
            };
            if (changeTypePrompt.choices.length === 0) {
                console.log('No valid changeTypes available, aborting');
                return;
            }
            const showChangeTypePrompt = changeTypePrompt.choices.length > 1;
            const response = yield prompts_1.default([
                {
                    type: 'autocomplete',
                    name: 'comment',
                    message: 'Describe changes (type or choose one)',
                    suggest: input => {
                        return Promise.resolve([...recentMessages.filter(msg => msg.startsWith(input)), input]);
                    }
                },
                ...(showChangeTypePrompt ? [changeTypePrompt] : []),
            ]);
            if (Object.keys(response).length === 0) {
                console.log('Cancelled, no change files are written');
                return;
            }
            packageChangeInfo[pkg] = Object.assign({}, response, { packageName: pkg, email: git_1.getUserEmail(cwd) || 'email not defined', commit: git_1.getCurrentHash(cwd) || 'hash not available', date: new Date() });
        }
        return packageChangeInfo;
    });
}
exports.promptForChange = promptForChange;
/**
 * Loops through the `changes` and writes out a list of change files
 * @param changes
 * @param cwd
 */
function writeChangeFiles(changes, cwd) {
    if (Object.keys(changes).length === 0) {
        return;
    }
    const changePath = paths_1.getChangePath(cwd);
    const branchName = git_1.getBranchName(cwd);
    if (changePath && !fs_extra_1.default.existsSync(changePath)) {
        fs_extra_1.default.mkdirpSync(changePath);
    }
    if (changes && branchName && changePath) {
        Object.keys(changes).forEach(pkgName => {
            const suffix = branchName.replace(/[\/\\]/g, '-');
            const prefix = pkgName.replace(/[^a-zA-Z0-9@]/g, '-');
            const fileName = `${prefix}-${getTimeStamp()}-${suffix}.json`;
            const changeFile = path_1.default.join(changePath, fileName);
            const change = changes[pkgName];
            fs_extra_1.default.writeFileSync(changeFile, JSON.stringify(change, null, 2));
        });
        git_1.stageAndCommit([path_1.default.join(changePath, '*.json')], 'Change files', cwd);
    }
}
exports.writeChangeFiles = writeChangeFiles;
function unlinkChangeFiles(cwd) {
    const changePath = paths_1.getChangePath(cwd);
    if (!changePath) {
        return;
    }
    fs_extra_1.default.removeSync(changePath);
}
exports.unlinkChangeFiles = unlinkChangeFiles;
function leftPadTwoZeros(someString) {
    return ('00' + someString).slice(-2);
}
function getTimeStamp() {
    let date = new Date();
    return [
        date.getFullYear(),
        leftPadTwoZeros((date.getMonth() + 1).toString()),
        leftPadTwoZeros(date.getDate().toString()),
        leftPadTwoZeros(date.getHours().toString()),
        leftPadTwoZeros(date.getMinutes().toString()),
        leftPadTwoZeros(date.getSeconds().toString())
    ].join('-');
}
function readChangeFiles(cwd) {
    const changePath = paths_1.getChangePath(cwd);
    if (!changePath || !fs_extra_1.default.existsSync(changePath)) {
        return [];
    }
    const changeFiles = fs_extra_1.default.readdirSync(changePath);
    const changes = [];
    changeFiles.forEach(changeFile => {
        try {
            changes.push(JSON.parse(fs_extra_1.default.readFileSync(path_1.default.join(changePath, changeFile)).toString()));
        }
        catch (e) {
            console.warn(`Invalid change file detected: ${changeFile}`);
        }
    });
    return changes;
}
exports.readChangeFiles = readChangeFiles;
function getPackageChangeTypes(cwd) {
    const changeTypeWeights = {
        major: 4,
        minor: 3,
        patch: 2,
        prerelease: 1,
        none: 0
    };
    const changes = readChangeFiles(cwd);
    const changePerPackage = {};
    changes.forEach(change => {
        const { packageName } = change;
        if (change.type === 'none') {
            return;
        }
        if (!changePerPackage[packageName] || changeTypeWeights[change.type] > changeTypeWeights[changePerPackage[packageName]]) {
            changePerPackage[packageName] = change.type;
        }
    });
    return changePerPackage;
}
exports.getPackageChangeTypes = getPackageChangeTypes;
