"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const paths_1 = require("./paths");
const git_1 = require("./git");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
/**
 * Gets all the changed packages, regardless of the change files
 * @param cwd
 */
function getAllChangedPackages(branch, cwd) {
    const changes = git_1.getChanges(branch, cwd);
    const packageRoots = {};
    if (changes) {
        // Discover package roots from modded files
        changes.forEach(moddedFile => {
            const root = paths_1.findPackageRoot(path_1.default.join(cwd, path_1.default.dirname(moddedFile)));
            if (root && !packageRoots[root]) {
                try {
                    const packageJson = JSON.parse(fs_1.default.readFileSync(path_1.default.join(root, 'package.json')).toString());
                    if (!packageJson.private && (!packageJson.beachball || packageJson.beachball.shouldPublish !== false)) {
                        const packageName = packageJson.name;
                        packageRoots[root] = packageName;
                    }
                }
                catch (e) {
                    // Ignore JSON errors
                }
            }
        });
    }
    return Object.values(packageRoots);
}
/**
 * Gets all the changed packages, accounting for change files
 * @param cwd
 */
function getChangedPackages(branch, cwd) {
    const changePath = paths_1.getChangePath(cwd);
    const changedPackages = getAllChangedPackages(branch, cwd);
    const changeFileResult = git_1.git(['ls-tree', '-r', '--name-only', '--full-tree', branch, 'change'], { cwd });
    if (!changePath || !fs_1.default.existsSync(changePath) || !changeFileResult.success) {
        return changedPackages;
    }
    const remoteChangeFiles = changeFileResult.stdout.split(/\n/).map(line => path_1.default.basename(line.trim()));
    const changeFiles = fs_1.default.readdirSync(changePath).filter(entry => fs_1.default.statSync(path_1.default.join(changePath, entry)).isFile);
    const changeFilePackageSet = new Set();
    changeFiles.forEach(file => {
        if (file === 'CHANGELOG.md' || file === 'CHANGELOG.md' || remoteChangeFiles.includes(file)) {
            return;
        }
        try {
            const changeInfo = JSON.parse(fs_1.default.readFileSync(path_1.default.join(changePath, file)).toString());
            changeFilePackageSet.add(changeInfo.packageName);
        }
        catch (e) {
            console.warn(`Invalid change file encountered: ${file}`);
        }
    });
    return changedPackages.filter(pkgName => !changeFilePackageSet.has(pkgName));
}
exports.getChangedPackages = getChangedPackages;
